بخش اولیه کد شامل ورودی‌هایی است که کاربر از طریق 
\lr{UI}
وارد می‌کند و همانطور که در شکل زیر می‌بینید در قالب فرمت
\lr{struct}
آمده‌است:

\begin{latin}
	\lstinputlisting[style={verilog-style}]{src/remotexyStruct.ino}
\end{latin}

این ورودی‌ در بخش حلقه اصلی کد به ازای شاخه انتخابی در یک ساختار
\lr{Config}
به ازای هر شاخه ذخیره می‌شوند. ساختار 
\lr{Config}
به ازای هر شاخه یک زیر نوع به فرم زیر است.
\begin{latin}
	\lstinputlisting[style={verilog-style}]{src/branchConfigs.ino}
\end{latin}

در ابتدای کار این مقادیر به صورت زیر مقداردهی اولیه می‌شوند.
\begin{latin}
	\lstinputlisting[style={verilog-style}]{src/setupConf.ino}
\end{latin}
و به صورت زیر در هر مرحله مقادیر ورودی شاخه از طریق 
\lr{UI}
به ازای شاخه مورد نظر وارد می‌شود. لازم به ذکر است که برنامه به نحوی زده شده که اگر بیشتر از دو شاخه نیز داشته باشیم باز هم بدون هیچ مشکلی کار کند. 

\begin{latin}
	\lstinputlisting[style={verilog-style}]{src/mainLoopSetupConf.ino}
\end{latin}

توجه کنید اگر مقدار
\lr{conf-activated}
به ازای یکی از شاخه‌ها غیر فعال باشد یعنی در حلقه اصلی مقدار خروجی این شاخه از روی شاخه‌های دیگر محاسبه می‌شود و لازم به مقدار دهی آن نیستیم. توجه کنید اگر شاخه‌ای شاخه قبلش روی حالت 
\lr{inverted}
تنظیم شده باشد یعنی این شاخه و قبلی به صورت رقص نور و سنکرون باهم تغییر می‌کنند و شاخه قبلی مقدار خروحی این شاخه را تنظیم می‌کند.


در بخش بعدی از حلقه اصلی روی تمامی شاخه‌ها پیمایش می‌کنیم و به ازای شاخه‌هایی که باید مقدار خروجی‌شان را تعیین کنیم بر اساس مقادیر داده شده در
\lr{branch-conf}
مقدار خروجی این پین را تنظیم می‌کنیم.

مقدار خروجی بر اساس ورودی بر اساس چهار تا از پارامتر‌های کانفیگ هر شاخه تنظیم می‌شود:
\begin{itemize}
	\item 
	اگر مقدار
	\lr{conf.power}
	برابر با صفر باشد یعنی این شاخه غیر فعال شده و در نتیجه مقدار خروجی‌ آن مستقل از هر چیز دیگری برابر صفر است.
	
	\item 
	مقدار
	\lr{conf.brightness-mode}
	به شاخه می‌گوید که ورودی سنسور را در این شاخه لحاظ کنیم یا نه. در صورتیکه این مقدار صفر باشد، مقدار خروجی برابر
	\lr{conf.min}
	خواهد بود و در صورتیکه برابر یک باشد به صورت 
	\lr{adaptive}
	از روی ورودی سنسور خروجی‌اش تنظیم می‌شود. مقدار خروجی بر اساس ورودی سنسور یک تابع خطی است. ابتدا تابع زیر را در نظر بگیرید که اسکیل کردن یک مقدار
	\lr{ratio}
	بین دو بازه استفاده می‌شود.
	$$scale(l, x, r) = (1 - x) \times l + x \times r$$
	 و مطابق با فرمول زیر مقدار ورودی سنسور را تبدیل به عددی بین صفر و یک می‌کنیم
	$$b = 1 - \min(1, \frac{x}{scale(s_{\min} , s , s_{\max})})$$
	این خروجی باید بین 
	\lr{brightness-max}
	و
	\lr{brightness-min}
	تنظیم شود و به صورت زیر این‌کار انجام می‌شود.
	$$out = scale(brightness_{\min}, b, brightness_{\max})$$
	
	توجه کنید به ازای این کد خاص مقدار
	$s_{\min}$
	و
	$s_{\max}$
	به ترتیب برابر ۱۰ و ۱۵۰ شده‌اند که محدوده بیشترین نور و کمترین نور در اتاق محل آزمایش است. همچنین مقدار
	$s$
	نیز یک پارامتر قابل تنظیم است که از طریق ورودی 
	\lr{UI}
	و مقدار
	\lr{conf.sensitivity}
	تنظیم می‌شود.
	
	
	ابتدا مقدار روشنایی اولیه هر کدام از \lr{LED} ها را برابر صفر تنظیم می‌کنیم و در ادامه این حلقه مقدار اصلی آن‌ها مشخص می‌شود.
	\begin{latin}
		\lstinputlisting[style={verilog-style}]{src/brightnessSetup.ino}
	\end{latin}
	
	در کد زیر نیز روشن بودن یا نبودن هر شاخه را مشخص می‌کنیم.
	\begin{latin}
		\lstinputlisting[style={verilog-style}]{src/branchPower.ino}
	\end{latin}
	در تکه کد زیر، روشنایی هر شاخه با توجه به تنظیمات خودکار (\lr{Adaptive}) و با توجه به سنسور تنظیم می‌شود.
	\begin{latin}
		\lstinputlisting[style={verilog-style}]{src/adaptiveS.ino}
	\end{latin}
در تکه کد زیر، روشنایی هر شاخه در حالت تنظیمات ثابت تنظیم می‌شود.
	\begin{latin}
	\lstinputlisting[style={verilog-style}]{src/staticS.ino}
\end{latin}

	\item
	مقدار 
	\lr{conf.inverted-mode}
	برابر صفر یا یک است که اگر برابر یک باشد یعنی این شاخه و شاخه بعدی رقص نور انجام می‌دهند. برای پیاده‌سازی این رقص نور مقدار خروجی آیتم بعدی که برابر با
	$out$
	بود را در نظر می‌گیریم و به ترتیب مقدار این شاخه و بعدی اش را مطابق دنباله زیر تنظیم می‌کنیم:
	$$<(\frac{out}{2}, \frac{out}{2}), (\frac{out}{2} + 1, \frac{out}{2} - 1), (\frac{out}{2} + 2, \frac{out}{2} - 2) ... >$$
	برای اینکه فرمت خروجی پویا باشد از یک پارامتر شمارنده به اسم
	\lr{nxt-branch-counter}
	بهره بردیم و این مقدار هر سری در بین بازه‌ای معقول قرار می‌گیرد و به شاخه اول اضافه می‌شود و از شاخه دوم کم می‌شود. به این ترتیب همیشه جمع اندازه خروجی این دو شاخه متوالی برابر با مقدار خروجی‌ای‌است که به ازای شاخه اولی تنظیم شده‌بود.
		\begin{latin}
		\lstinputlisting[style={verilog-style}]{src/inverted.ino}
	\end{latin}
\end{itemize}

برای اطلاعات بیشتر از بخش‌های کد می‌توانید سورس کامل را در پیوست های پروژه به همراه مستندات کامل مشاهده نمایید.

